# sort_brief_alignment

sort brief_alignment files

the output format doesn't change

The `<` is defined as follows:

```
if(a.ref_start < b.ref_start)   return true;
if(a.ref_start > b.ref_start)   return false;
if(a.ref_end > b.ref_end)   return true;
return false;
```

`ref_start` is the first entry in a line
`ref_end` is the second entry in a line

# concordant_aln_analysis

* Input file: the sorted file generated by `bamExtractor.py` and `sort_brief_alignment`
* Output file: validated segments
    * Each line contains a pair of locations/integers (left inclusive and right exclusive), indicating a validated segment 
    * The output is guaranteed to be sorted in ascending order

```
Usage: concordant_aln_analysis <required parameters>

required parameters should be strictly in the following order:
    1. Length of the reference
    2. Minimum cutoff for identifying one coverage for a base
    3. Minimum overlap for identifying consecutive validated segment
    4. Minimum length of an alignment in consideration
    5. Minimum mapping quality in consideration
    6. Input file name
    7. Output file name
    8. Minimum coverage for an alignment to be kept
    9. Minimum coverage ratio for an alignment to be kept
```

# discordant_type1

* Input file: the sorted file generated by `bamExtractor.py` and `sort_brief_alignment`
* Output file: predicted inversions
    * each line contains four locations / integers (left inclusive and right exclusive)
        * left_breakpoint_x left_breakpoint_y right_breakpoint_x right_breakpoint_y

```
Usage: discordant_type1 <required parameters>

The following are the list of required parameters, which should be provided in order:
    1. Input file of sorted extracted brief alignment file
    2. Output file of type 1 alignments
    3. delta1: Maximum allowed difference between the inversions of ref and qry
    4. ptg1:    Minimum required percentage of coverage for the inversions of ref and qry
    5. min_MAP: Minium allowed MAQ value
    6. Maximum allowed overlap for inversion analysis
```

### TODO

- [ ] Use Trie instead of map
- [ ] Use Longest Increasing Sequence instead of the naive algorithm
- [ ] Use binary file format
- [ ] Provide more detailed inversion/alignment information

# discordant_type2

* Input file: the sorted file generated by `bamExtractor.py` and `sort_brief_alignment`
* Output file: predicted inversions
    * each line contains `<LBP_x> <LBP_y> <RBP_x> <RBP_y> <side> <dist>`
        * `LBP` stands for *left breakpoint*
        * `RBP` stands for *right breakpoint*
        * `<side>` is either `[` or `]`, signifying that the left or the right neighbor is anchored by this alignment.
        * `<dist>` is the actual distance or overlap of two split reads.
            * Negative means the two split reads overlap, and the predicted breakpoints should reside in a pair of Inverted Repeats (IR) symmetrically.
            * Non-negative means the split reads are apart from each other. This is the previous ideal case

```
Usage: discordant_type2 <required parameters>

Please provide the following parameters in order:
    1. Input file of sorted extracted brief alignment file
    2. Output file of type 2 alignments
    3. min_MAPQ: Minimum allowed MAPQ value
    4. min_extension: Minimum extended length when two split reads overlap
    5. Ksi: Allowed error for assessing break points
    6. Maximum allowed distance between adjacent aligned piece of the reads
```

### TODO

- [ ] Use Trie instead of map
- [ ] Use binary file format
- [ ] Provide more detailed inversion/alignment information
- [ ] Consider only adjacent alignment instead of all the alignments

# discordant_type3

* Input files: two sorted file generated by `bamExtractor.py` and `sort_brief_alignment`
* Output file: predicted inversions
    * there are 4 output files, suffixed with `_FF`, `_FR`, `_RF`, `_RR`
        * `_FF`: for `[]`
        * `_FR`: for `[[`
        * `_RF`: for `]]`
        * `_RR`: for `][`
    * each line containes four locations / integers (left inclusive and right exclusive)
        * left_breakpoint_x left_breakpoint_y right_breakpoint_x right_breakpoint_y

```
Usage: discordant_type3 <required parameters>

Please provide the following parameters in order:
    1. Input file of sorted extracted brief alignment for scaffold 1
    2. Input file of sorted extracted brief alignment for scaffold 2
    3. Output file prefix of type 3 discordant alignment for scaffold 1 and 2
    4. min_MAPQ: Minimum allowed MAPQ value
    5. Maximum allowed overlap for inversion analysis
    6. Ksi: Allowed error for assessing break points
```

### TODO

- [ ] Use Trie instead of map
- [ ] Use binary file format
- [ ] Provide more detailed inversion/alignment information

# ~~segment_prediction~~

**Not finished yet**

Predict the horizontal segment and vertical segment separately, instead of the whole rectangle

# ~~brute_force_rect_prediction~~

**N.B.** This is not required

Apply the brute force algorithm to predict the representative rectangle. The running time is pseudo-polynomial

* Input file: each line has four integers representing `left right bottom top` of a rectangle
* Output file: one line containing the `left right bottom top` of the representative rectangle
    * If the representative rectangle does not exist, then there is no output file

```
Usage: brute_force_rect_prediction <required parameters>

Please provide the following parameters in order:
    1. Input file of the set of rectangles
    2. Output file of the set of rectangle
    3. epsilon
    4. delta
```

# ~~prob_rect_prediction~~

**N.B.** This is not required, because we have the following clustering algorithm

# partition_disconnected_rects

Partition the rectangles in a file into connected components

* Input: a file containing a set of rectangles. In rectangle format
* Output directory: A directory containing all the connected components
    * `spec.txt`: each line has at least 2 entries: `<connected component ID>` and `directory of <path to the connected component>`
        * `<path to the connected component>` is the file containing the rectangles
        * in the current version, there is a 3rd entry, which is the number of rectangles in this cluster

```
Usage: partition_disconnected_rects <required parameters>

Please provide the following parameters in order:
    1. Input file of a set of rectangles
    2. Output directory
    3. Keep only the connected component that has at least this number of rectangles
    4. Keep only the rectangles whose side lengths are smaller than this value (set as 0 if one wants to keep all the rectangles)
```

The current implementation first partition the x-edges and then partition the y-edges. And then, for each small group, run the naive algorithm to partition the rectangles

**TODO**

Implement the algorithm in the paper *A Space-Efficient Algorithm for Finding the Connected Components of Rectangles in the Plane*, or use min-heap to improve the running time

Idea:

```
Let L be an array of current connected rectangles
Let H be the min-heap (key is left value of the rectangles)
for i = 1, 2, ..., len(L)
    Q = empty
    if min(H) <= L[i].right
        add min(H) to Q
    while Q is not empty
        t = Q.pop_tail() # use pop_tail because the following step requires it
        if t intersects with L[i]
            add t to L  # hence the size of L increases by 1
            remove t from H  # This will not cause trouble to the other elements in Q because only the children of t (which are not in Q), and the last element in the array of H will be affected. The last element in H should not be in H at this stage because in the following two steps, we add t.left to Q before t.right
        if t.left <= L[i].right
            add t.left to Q
        if t.right <= L[i].right
            add t.right to Q
    
``` 

# cluster_by_maximal_coverage

A heuristic local maximal coverage algorithm for clustering rectangles

* Input file: the rectangle format
* Output: In the output directory
    * `predictions.sol`: each line is a predicted rectangle. The file is in format
    * `spec.txt`: if exists, each line is of the format `<id> <path prefix of the cluster>`
        * In the subdirectories, each `<path prefix of the cluster>.txt` is a cluster in the rectangle file format


```
Usage: cluster_by_maximal_coverage <required parameters>

Please provide the following parameters in order:
     1. Input file name of a set of rectangles
     2. Output directory
     3. p: lower bound of the probability of one rectangle containing the target
         point
     4. delta: confidence parameter (close to 0 is better)
     5. Minimum number of rectangles required to estimate the representative rec
        tangle
     6. Set maximum allowed side length of the predicted representative rectangl
        es (0 if ignore this parameter)
     7. Remove this portion of large rectangles
     8. Set to 1 if the first step is to try to compute a representative rectang
        le for all rectangles
     9. Set to 1 if want to remove representative rectangles that overlap one an
        other
    10. If the number of alignments less than this number, the inversion will no
        t be considered
    11. if min(lbrace/rbrace, rbrace/lbrace) is less than this number, the inver
        sion will not be considered
```

# refine_type2

Refine the type2 predictions by combining them with the validated segments

* Input file 1: the validated segments. The validated segments are already sorted
* Root directory of the type2 results:
    * `<root_directory/spec.txt>`
        * each line has at least 2 entries: `<connected component ID>` and `<path to that connected component>`
            * the `<path to that connected component>` is in rectangle format
        * In the directory of `<path to that connected component>`, there is a `<connected component_ID>_sol/` directory. It contains
            * `predictions.sol`: in rectangle format
            * `spec.txt` if it exists. But not used in this analysis
            * some subdirectories containing the detailed clusters
* output format: each line is a prediction of the intervals of the breakpoints. In rectangle format


```
Usage: refine_type2 <required parameters>

Please provide the following parameters in order:
    1. Input file for the results of concordant analysis
    2. Root directory of the type2 results
    3. Output filename
```

# sampling_lines

Sample lines from a file. This utility is used as a compromise when the rectangle files are too large. And it will be removed after the code is further improved.

```
Usage: sampling_lines <required parameters>

Please provide the following parameters in order:
    1. Input file name
    2. Output file name
    3. Sample this number of lines (unless = 0)
    4. Sample with this probability (when n_lines = 0)
    5. An integer added to the seed
```

# merge_files

Merge several files listed in the `spec.txt`

* The input directory should contain a `spec.txt` that
    * It has an entry that is the ID of the target file
    * And an entry that is the path of the target file
    * The target file is `<PATH>/<ID><suffix>`
* Output: a single file of the original format

```
Usage: merge_files <required parameters>

Please provide the following parameters in order:
    1. Root directory of the files to be merged
    2. Output filename
    3. There are at least this number of entries per line
    4. The index of the entries for the ID of the file
    5. The index of the entries for the PATH of the file
    6. The suffix of the filename. Set as $ if no suffix
```
