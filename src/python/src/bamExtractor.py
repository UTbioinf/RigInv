#!/usr/bin/env python

import sys
import argparse
import os
import pysam

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), "..", "..", "lib", "python", "riginv_lib"))

import util
import ManyFiles

def run(args):
    basedir = os.path.join(args.directory, "intermediate_results")
    util.makedir(basedir)
    fin_bam = pysam.AlignmentFile(args.bam, "rb")
    fout = open(os.path.join(basedir, "spec.txt"), "w")
    if args.mk_file:
        fout_mk = open(os.path.join(basedir, "inc.mk"), "w")
        fout_mk.write("ALN_ROOTDIR=\"{}\"\n".format( basedir ))
        fout_mk.write("ALN_SOURCES=")

    ref_ids = ManyFiles.ManyWriteFiles(args.max_nfiles - 2, args.cache_size)
    ref_lengths = fin_bam.lengths
    for aln in fin_bam.fetch(until_eof = True):
        # N.B. the bam file generated by bwa-mem could have reference_id == -1. Before finding a better way to resolve this issue, skip this alignment for now
        if aln.reference_id < 0 or aln.reference_id >= len(ref_lengths):
            continue
        fout_aln = ref_ids.get( aln.reference_id, None )
        if not fout_aln:
            composed_dir=util.int2path( aln.reference_id )
            directory_name = os.path.join(basedir, composed_dir)
            util.makedir( directory_name )
            aln_filename = os.path.join(directory_name, str(aln.reference_id) + ".txt")
            fout_aln = ref_ids.open(aln_filename, aln.reference_id)
            fout.write("{} {} {} {}\n".format(aln.reference_id, aln.reference_name, ref_lengths[ aln.reference_id ], directory_name))
            if args.mk_file:
                fout_mk.write("{} ".format(os.path.join(composed_dir, str(aln.reference_id))))
        ref_ids.write(fout_aln, "{} {} {} {} {} {} {} {} {}\n".format(
                aln.reference_start, aln.reference_end,
                aln.query_alignment_start, aln.query_alignment_end,
                aln.query_name, 
                aln.reference_length, aln.query_length,
                aln.mapping_quality if aln.mapping_quality != "*" else 0, 'R' if aln.is_reverse else 'F'))
    ref_ids.close()
    fout.close()
    if args.mk_file:
        if ref_ids:
            fout_mk.write("ALN_RUN=1\n")
        else:
            fout_mk.write("ALN_RUN=0\n")
        fout_mk.close()
    fin_bam.close()
        

def parse_args( argv = None ):
    parser = argparse.ArgumentParser(prog="bamExtractor", description = "Bam file extractor")
    parser.add_argument('-b', "--bam", required = True, help="bam/sam file name")
    # TODO
    # parse sam file as well
    parser.add_argument("-d", "--directory", default=".", help="directory of the output file. If not set, it will be the current directory")
    parser.add_argument("-m", "--mk-file", action="store_true", help="generate the 'inc.mk' file for makefiles")
    parser.add_argument("--max-nfiles", default=512, type=int, help="Only keep <= this number of files open (default: %(default)s)")
    parser.add_argument("--cache-size", default=1048576, type=int, help="Hold <= this number of bytes for each file before flushing to the disk")
    return parser.parse_args( argv )

def main( argv = None ):
    args = parse_args( argv )
    run( args )

if __name__ == '__main__':
    main()
